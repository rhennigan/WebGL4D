// Generated by CoffeeScript 1.9.1
(function() {
  var Main;

  Main = (function() {
    var animate, center, computeFPS, cubeTexture, currentDirection, dragCurrent, dragOffset, dragStart, drawScene, drawTesseract, fps, gl, handleTextureLoaded, i, initBuffers, initGL, initShaders, lastTime, lightDirectionVector, loadShader, modalRotate, mouseDragging, moveSpeed, mvMatrix, pMatrix, pVector, pw, px, py, pz, r1Float, r2Float, r3Float, r4Float, r5Float, r6Float, rSpeeds, randAngle, setMatrixUniforms, shaderProgram, shaders, tVector, tick, timeLast, timeNow, updateSpeeds, vertexColorBuffer, vertexCornerNormalBuffer, vertexIndexBuffer, vertexLineIndexBuffer, vertexLinePositionBuffer, vertexNormalBuffer, vertexPositionBuffer, vertexTextureCoordinateBuffer;

    function Main() {}

    Main.prototype.cornerNormals = true;

    Main.prototype.meshBool = true;

    Main.prototype.meshColorGui = [255, 255, 255, 1.0];

    Main.prototype.meshColor = vec4.fromValues(255, 255, 255, 1.0);

    Main.prototype.separation = 1.0;

    Main.prototype.cellCount = 2;

    Main.prototype.GLDepthTest = true;

    Main.prototype.GLBlend = true;

    Main.prototype.lightX = 0.5;

    Main.prototype.lightY = 0.5;

    Main.prototype.lightZ = 1.0;

    Main.prototype.lightW = 1.0;

    Main.prototype.autoRotate = true;

    Main.prototype.autoRotateSpeed = 4.0 * Math.PI;

    Main.prototype.rhXY = 0.5;

    Main.prototype.rhXZ = 1.0;

    Main.prototype.rhXW = 1.5;

    Main.prototype.rhYZ = 0.0;

    Main.prototype.rhYW = 0.0;

    Main.prototype.rhZW = 0.0;

    Main.prototype.rvXY = 0.0;

    Main.prototype.rvXZ = 0.0;

    Main.prototype.rvXW = 0.0;

    Main.prototype.rvYZ = 0.5;

    Main.prototype.rvYW = 1.0;

    Main.prototype.rvZW = 1.5;

    gl = void 0;

    shaders = {
      fragReady: false,
      vertReady: false,
      frag: void 0,
      vert: void 0
    };

    shaderProgram = void 0;

    mvMatrix = mat4.create();

    pMatrix = mat4.create();

    tVector = vec4.create();

    pVector = vec4.create();

    lightDirectionVector = vec4.create();

    randAngle = function() {
      return 0.25 * Math.random() - 0.125;
    };

    r1Float = 8.0 * Math.PI * randAngle();

    r2Float = 8.0 * Math.PI * randAngle();

    r3Float = 8.0 * Math.PI * randAngle();

    r4Float = 8.0 * Math.PI * randAngle();

    r5Float = 8.0 * Math.PI * randAngle();

    r6Float = 8.0 * Math.PI * randAngle();

    vertexPositionBuffer = void 0;

    vertexTextureCoordinateBuffer = void 0;

    vertexColorBuffer = void 0;

    vertexNormalBuffer = void 0;

    vertexCornerNormalBuffer = void 0;

    vertexIndexBuffer = void 0;

    vertexLinePositionBuffer = void 0;

    vertexLineIndexBuffer = void 0;

    cubeTexture = void 0;

    initGL = function(canvas) {
      var e;
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
        window.main.GL = gl;
      } catch (_error) {
        e = _error;
        alert("initGL error: " + e);
      }
      if (!gl) {
        return alert("Could not initialize WebGL");
      }
    };

    loadShader = function(path, type) {
      var request;
      request = new XMLHttpRequest();
      request.open('GET', path, true);
      request.onreadystatechange = function() {
        var sourceString;
        if (request.readyState === 4 && request.status === 200) {
          sourceString = request.responseText;
          if (type === 'frag') {
            shaders.frag = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(shaders.frag, sourceString);
            gl.compileShader(shaders.frag);
            if (!gl.getShaderParameter(shaders.frag, gl.COMPILE_STATUS)) {
              return console.log("Error compiling frag: " + gl.getShaderInfoLog(shaders.frag));
            } else {
              return shaders.fragReady = true;
            }
          } else if (type === 'vert') {
            shaders.vert = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shaders.vert, sourceString);
            gl.compileShader(shaders.vert);
            if (!gl.getShaderParameter(shaders.vert, gl.COMPILE_STATUS)) {
              return console.log("Error compiling vert: " + gl.getShaderInfoLog(shaders.vert));
            } else {
              return shaders.vertReady = true;
            }
          } else {
            return alert("unknown shader type: " + type);
          }
        }
      };
      return request.send();
    };

    initShaders = function() {
      if (!shaders.fragReady) {
        return alert("fragment shader script is not loaded");
      } else if (!shaders.vertReady) {
        return alert("vertex shader script is not loaded");
      } else {
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, shaders.vert);
        gl.attachShader(shaderProgram, shaders.frag);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          console.log(shaders);
          return alert("failed to initialize shaders");
        } else {
          gl.useProgram(shaderProgram);
          shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
          shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
          shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
          shaderProgram.vertexTextureCoordinateAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
          gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
          gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
          gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
          gl.enableVertexAttribArray(shaderProgram.vertexTextureCoordinateAttribute);
          shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
          shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
          shaderProgram.tVectorUniform = gl.getUniformLocation(shaderProgram, "uTVector");
          shaderProgram.pVectorUniform = gl.getUniformLocation(shaderProgram, "uPVector");
          shaderProgram.lightDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightDirection");
          shaderProgram.r1FloatUniform = gl.getUniformLocation(shaderProgram, "uR1Float");
          shaderProgram.r2FloatUniform = gl.getUniformLocation(shaderProgram, "uR2Float");
          shaderProgram.r3FloatUniform = gl.getUniformLocation(shaderProgram, "uR3Float");
          shaderProgram.r4FloatUniform = gl.getUniformLocation(shaderProgram, "uR4Float");
          shaderProgram.r5FloatUniform = gl.getUniformLocation(shaderProgram, "uR5Float");
          shaderProgram.r6FloatUniform = gl.getUniformLocation(shaderProgram, "uR6Float");
          shaderProgram.meshBoolUniform = gl.getUniformLocation(shaderProgram, "uMeshBool");
          return shaderProgram.meshColorUniform = gl.getUniformLocation(shaderProgram, "uMeshColor");
        }
      }
    };

    setMatrixUniforms = function() {
      gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
      gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
      gl.uniform4fv(shaderProgram.tVectorUniform, tVector);
      gl.uniform4fv(shaderProgram.pVectorUniform, pVector);
      gl.uniform4fv(shaderProgram.lightDirectionUniform, lightDirectionVector);
      gl.uniform1f(shaderProgram.r1FloatUniform, r1Float);
      gl.uniform1f(shaderProgram.r2FloatUniform, r2Float);
      gl.uniform1f(shaderProgram.r3FloatUniform, r3Float);
      gl.uniform1f(shaderProgram.r4FloatUniform, r4Float);
      gl.uniform1f(shaderProgram.r5FloatUniform, r5Float);
      gl.uniform1f(shaderProgram.r6FloatUniform, r6Float);
      gl.uniform1i(shaderProgram.meshBoolUniform, window.main.meshBool);
      return gl.uniform4fv(shaderProgram.meshColorUniform, window.main.meshColor);
    };

    window.createCubeTexture = function(text) {
      var cubeImage, texture;
      cubeImage = document.getElementById('qcCanvas');
      cubeTexture = texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      handleTextureLoaded(cubeImage, texture);
      return texture;
    };

    handleTextureLoaded = function(image, texture) {
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);
      return gl.bindTexture(gl.TEXTURE_2D, null);
    };

    initBuffers = function() {
      var i, lineVertices, normals, normalsC, textureCoordinates, unpackedColors, vertexIndices, vertexLineIndices, vertices;
      vertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
      vertices = [-1, -1, -1, 1, -1, 1, -1, 1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, -1, 1, -1, 1, -1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, 1, -1, 1, -1, -1, -1, -1, 1, -1, 1, -1, 1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, 1, 1, 1, -1, -1, -1, 1, -1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, 1, -1, -1, -1, 1, -1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, 1, 1, 1, -1, -1, -1, 1, -1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, 1, -1, 1];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      vertexPositionBuffer.itemSize = 4;
      vertexPositionBuffer.numItems = 192;
      vertexTextureCoordinateBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexTextureCoordinateBuffer);
      textureCoordinates = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
      vertexTextureCoordinateBuffer.itemSize = 2;
      vertexTextureCoordinateBuffer.numItems = 192;
      vertexColorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
      unpackedColors = [0.6682, 0.5, 0.125, 0.5, 0.6682, 0.5, 0.125, 0.5, 0.6682, 0.5, 0.125, 0.5, 0.6682, 0.5, 0.125, 0.5, 0.6682, 1.0, 0.125, 0.5, 0.6682, 1.0, 0.125, 0.5, 0.6682, 1.0, 0.125, 0.5, 0.6682, 1.0, 0.125, 0.5, 0.1682, 1.0, 0.125, 0.5, 0.1682, 1.0, 0.125, 0.5, 0.1682, 1.0, 0.125, 0.5, 0.1682, 1.0, 0.125, 0.5, 0.6682, 0.625, 0.25, 0.5, 0.6682, 0.625, 0.25, 0.5, 0.6682, 0.625, 0.25, 0.5, 0.6682, 0.625, 0.25, 0.5, 0.6682, 0.5, 0.625, 0.5, 0.6682, 0.5, 0.625, 0.5, 0.6682, 0.5, 0.625, 0.5, 0.6682, 0.5, 0.625, 0.5, 0.1682, 0.5, 0.625, 0.5, 0.1682, 0.5, 0.625, 0.5, 0.1682, 0.5, 0.625, 0.5, 0.1682, 0.5, 0.625, 0.5, 0.5072, 0.5, 0.405, 0.5, 0.5072, 0.5, 0.405, 0.5, 0.5072, 0.5, 0.405, 0.5, 0.5072, 0.5, 0.405, 0.5, 0.5072, 1.0, 0.405, 0.5, 0.5072, 1.0, 0.405, 0.5, 0.5072, 1.0, 0.405, 0.5, 0.5072, 1.0, 0.405, 0.5, 0.0072, 1.0, 0.405, 0.5, 0.0072, 1.0, 0.405, 0.5, 0.0072, 1.0, 0.405, 0.5, 0.0072, 1.0, 0.405, 0.5, 0.5072, 0.625, 0.53, 0.5, 0.5072, 0.625, 0.53, 0.5, 0.5072, 0.625, 0.53, 0.5, 0.5072, 0.625, 0.53, 0.5, 0.5072, 0.5, 0.905, 0.5, 0.5072, 0.5, 0.905, 0.5, 0.5072, 0.5, 0.905, 0.5, 0.5072, 0.5, 0.905, 0.5, 0.0072, 0.5, 0.905, 0.5, 0.0072, 0.5, 0.905, 0.5, 0.0072, 0.5, 0.905, 0.5, 0.0072, 0.5, 0.905, 0.5, 0.5, 0.5, 0.28125, 0.5, 0.5, 0.5, 0.28125, 0.5, 0.5, 0.5, 0.28125, 0.5, 0.5, 0.5, 0.28125, 0.5, 0.5, 1.0, 0.28125, 0.5, 0.5, 1.0, 0.28125, 0.5, 0.5, 1.0, 0.28125, 0.5, 0.5, 1.0, 0.28125, 0.5, 0.0, 1.0, 0.28125, 0.5, 0.0, 1.0, 0.28125, 0.5, 0.0, 1.0, 0.28125, 0.5, 0.0, 1.0, 0.28125, 0.5, 0.5, 0.625, 0.40625, 0.5, 0.5, 0.625, 0.40625, 0.5, 0.5, 0.625, 0.40625, 0.5, 0.5, 0.625, 0.40625, 0.5, 0.5, 0.5, 0.78125, 0.5, 0.5, 0.5, 0.78125, 0.5, 0.5, 0.5, 0.78125, 0.5, 0.5, 0.5, 0.78125, 0.5, 0.0, 0.5, 0.78125, 0.5, 0.0, 0.5, 0.78125, 0.5, 0.0, 0.5, 0.78125, 0.5, 0.0, 0.5, 0.78125, 0.5, 0.625, 0.5, 0.18, 0.5, 0.625, 0.5, 0.18, 0.5, 0.625, 0.5, 0.18, 0.5, 0.625, 0.5, 0.18, 0.5, 0.625, 1.0, 0.18, 0.5, 0.625, 1.0, 0.18, 0.5, 0.625, 1.0, 0.18, 0.5, 0.625, 1.0, 0.18, 0.5, 0.125, 1.0, 0.18, 0.5, 0.125, 1.0, 0.18, 0.5, 0.125, 1.0, 0.18, 0.5, 0.125, 1.0, 0.18, 0.5, 0.625, 0.625, 0.305, 0.5, 0.625, 0.625, 0.305, 0.5, 0.625, 0.625, 0.305, 0.5, 0.625, 0.625, 0.305, 0.5, 0.625, 0.5, 0.68, 0.5, 0.625, 0.5, 0.68, 0.5, 0.625, 0.5, 0.68, 0.5, 0.625, 0.5, 0.68, 0.5, 0.125, 0.5, 0.68, 0.5, 0.125, 0.5, 0.68, 0.5, 0.125, 0.5, 0.68, 0.5, 0.125, 0.5, 0.68, 0.5, 0.72445, 0.125, 0.245, 0.5, 0.72445, 0.125, 0.245, 0.5, 0.72445, 0.125, 0.245, 0.5, 0.72445, 0.125, 0.245, 0.5, 0.72445, 0.625, 0.245, 0.5, 0.72445, 0.625, 0.245, 0.5, 0.72445, 0.625, 0.245, 0.5, 0.72445, 0.625, 0.245, 0.5, 0.22445, 0.625, 0.245, 0.5, 0.22445, 0.625, 0.245, 0.5, 0.22445, 0.625, 0.245, 0.5, 0.22445, 0.625, 0.245, 0.5, 0.72445, 0.25, 0.37, 0.5, 0.72445, 0.25, 0.37, 0.5, 0.72445, 0.25, 0.37, 0.5, 0.72445, 0.25, 0.37, 0.5, 0.72445, 0.125, 0.745, 0.5, 0.72445, 0.125, 0.745, 0.5, 0.72445, 0.125, 0.745, 0.5, 0.72445, 0.125, 0.745, 0.5, 0.22445, 0.125, 0.745, 0.5, 0.22445, 0.125, 0.745, 0.5, 0.22445, 0.125, 0.745, 0.5, 0.22445, 0.125, 0.745, 0.5, 0.51445, 0.5, 0.18, 0.5, 0.51445, 0.5, 0.18, 0.5, 0.51445, 0.5, 0.18, 0.5, 0.51445, 0.5, 0.18, 0.5, 0.51445, 1.0, 0.18, 0.5, 0.51445, 1.0, 0.18, 0.5, 0.51445, 1.0, 0.18, 0.5, 0.51445, 1.0, 0.18, 0.5, 0.01445, 1.0, 0.18, 0.5, 0.01445, 1.0, 0.18, 0.5, 0.01445, 1.0, 0.18, 0.5, 0.01445, 1.0, 0.18, 0.5, 0.51445, 0.625, 0.305, 0.5, 0.51445, 0.625, 0.305, 0.5, 0.51445, 0.625, 0.305, 0.5, 0.51445, 0.625, 0.305, 0.5, 0.51445, 0.5, 0.68, 0.5, 0.51445, 0.5, 0.68, 0.5, 0.51445, 0.5, 0.68, 0.5, 0.51445, 0.5, 0.68, 0.5, 0.01445, 0.5, 0.68, 0.5, 0.01445, 0.5, 0.68, 0.5, 0.01445, 0.5, 0.68, 0.5, 0.01445, 0.5, 0.68, 0.5, 0.905, 0.5, 0.28125, 0.5, 0.905, 0.5, 0.28125, 0.5, 0.905, 0.5, 0.28125, 0.5, 0.905, 0.5, 0.28125, 0.5, 0.905, 1.0, 0.28125, 0.5, 0.905, 1.0, 0.28125, 0.5, 0.905, 1.0, 0.28125, 0.5, 0.905, 1.0, 0.28125, 0.5, 0.405, 1.0, 0.28125, 0.5, 0.405, 1.0, 0.28125, 0.5, 0.405, 1.0, 0.28125, 0.5, 0.405, 1.0, 0.28125, 0.5, 0.905, 0.625, 0.40625, 0.5, 0.905, 0.625, 0.40625, 0.5, 0.905, 0.625, 0.40625, 0.5, 0.905, 0.625, 0.40625, 0.5, 0.905, 0.5, 0.78125, 0.5, 0.905, 0.5, 0.78125, 0.5, 0.905, 0.5, 0.78125, 0.5, 0.905, 0.5, 0.78125, 0.5, 0.405, 0.5, 0.78125, 0.5, 0.405, 0.5, 0.78125, 0.5, 0.405, 0.5, 0.78125, 0.5, 0.405, 0.5, 0.78125, 0.5, 0.50605, 0.245, 0.28125, 0.5, 0.50605, 0.245, 0.28125, 0.5, 0.50605, 0.245, 0.28125, 0.5, 0.50605, 0.245, 0.28125, 0.5, 0.50605, 0.745, 0.28125, 0.5, 0.50605, 0.745, 0.28125, 0.5, 0.50605, 0.745, 0.28125, 0.5, 0.50605, 0.745, 0.28125, 0.5, 0.00605, 0.745, 0.28125, 0.5, 0.00605, 0.745, 0.28125, 0.5, 0.00605, 0.745, 0.28125, 0.5, 0.00605, 0.745, 0.28125, 0.5, 0.50605, 0.37, 0.40625, 0.5, 0.50605, 0.37, 0.40625, 0.5, 0.50605, 0.37, 0.40625, 0.5, 0.50605, 0.37, 0.40625, 0.5, 0.50605, 0.245, 0.78125, 0.5, 0.50605, 0.245, 0.78125, 0.5, 0.50605, 0.245, 0.78125, 0.5, 0.50605, 0.245, 0.78125, 0.5, 0.00605, 0.245, 0.78125, 0.5, 0.00605, 0.245, 0.78125, 0.5, 0.00605, 0.245, 0.78125, 0.5, 0.00605, 0.245, 0.78125, 0.5];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
      vertexColorBuffer.itemSize = 4;
      vertexColorBuffer.numItems = 192;
      vertexNormalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
      normals = [-1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
      vertexNormalBuffer.itemSize = 4;
      vertexNormalBuffer.numItems = 192;
      vertexCornerNormalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexCornerNormalBuffer);
      normalsC = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = vertices.length; j < len; j++) {
          i = vertices[j];
          results.push(i / 2);
        }
        return results;
      })();
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalsC), gl.STATIC_DRAW);
      vertexCornerNormalBuffer.itemSize = 4;
      vertexCornerNormalBuffer.numItems = 192;
      vertexIndexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
      vertexIndices = [0, 1, 2, 0, 3, 2, 4, 5, 6, 4, 7, 6, 8, 9, 10, 8, 11, 10, 12, 13, 14, 12, 15, 14, 16, 17, 18, 16, 19, 18, 20, 21, 22, 20, 23, 22, 24, 25, 26, 24, 27, 26, 28, 29, 30, 28, 31, 30, 32, 33, 34, 32, 35, 34, 36, 37, 38, 36, 39, 38, 40, 41, 42, 40, 43, 42, 44, 45, 46, 44, 47, 46, 48, 49, 50, 48, 51, 50, 52, 53, 54, 52, 55, 54, 56, 57, 58, 56, 59, 58, 60, 61, 62, 60, 63, 62, 64, 65, 66, 64, 67, 66, 68, 69, 70, 68, 71, 70, 72, 73, 74, 72, 75, 74, 76, 77, 78, 76, 79, 78, 80, 81, 82, 80, 83, 82, 84, 85, 86, 84, 87, 86, 88, 89, 90, 88, 91, 90, 92, 93, 94, 92, 95, 94, 96, 97, 98, 96, 99, 98, 100, 101, 102, 100, 103, 102, 104, 105, 106, 104, 107, 106, 108, 109, 110, 108, 111, 110, 112, 113, 114, 112, 115, 114, 116, 117, 118, 116, 119, 118, 120, 121, 122, 120, 123, 122, 124, 125, 126, 124, 127, 126, 128, 129, 130, 128, 131, 130, 132, 133, 134, 132, 135, 134, 136, 137, 138, 136, 139, 138, 140, 141, 142, 140, 143, 142, 144, 145, 146, 144, 147, 146, 148, 149, 150, 148, 151, 150, 152, 153, 154, 152, 155, 154, 156, 157, 158, 156, 159, 158, 160, 161, 162, 160, 163, 162, 164, 165, 166, 164, 167, 166, 168, 169, 170, 168, 171, 170, 172, 173, 174, 172, 175, 174, 176, 177, 178, 176, 179, 178, 180, 181, 182, 180, 183, 182, 184, 185, 186, 184, 187, 186, 188, 189, 190, 188, 191, 190];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndices), gl.STATIC_DRAW);
      vertexIndexBuffer.itemSize = 1;
      vertexIndexBuffer.numItems = 288;
      vertexLinePositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexLinePositionBuffer);
      lineVertices = [-1, -1, -1, -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, 1, 1];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lineVertices), gl.STATIC_DRAW);
      vertexLinePositionBuffer.itemSize = 4;
      vertexLinePositionBuffer.numItems = 16;
      vertexLineIndexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexLineIndexBuffer);
      vertexLineIndices = [0, 1, 0, 2, 0, 4, 0, 8, 1, 0, 1, 3, 1, 5, 1, 9, 2, 0, 2, 3, 2, 6, 2, 10, 3, 1, 3, 2, 3, 7, 3, 11, 4, 0, 4, 5, 4, 6, 4, 12, 5, 1, 5, 4, 5, 7, 5, 13, 6, 2, 6, 4, 6, 7, 6, 14, 7, 3, 7, 5, 7, 6, 7, 15, 8, 0, 8, 9, 8, 10, 8, 12, 9, 1, 9, 8, 9, 11, 9, 13, 10, 2, 10, 8, 10, 11, 10, 14, 11, 3, 11, 9, 11, 10, 11, 15, 12, 4, 12, 8, 12, 13, 12, 14, 13, 5, 13, 9, 13, 12, 13, 15, 14, 6, 14, 10, 14, 12, 14, 15, 15, 7, 15, 11, 15, 13, 15, 14];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexLineIndices), gl.STATIC_DRAW);
      vertexLineIndexBuffer.itemSize = 1;
      return vertexLineIndexBuffer.numItems = 128;
    };

    drawTesseract = function(x, y, z, w) {
      vec4.set(tVector, x, y, z, w);
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, vertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
      if (window.main.cornerNormals) {
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexCornerNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, vertexCornerNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
      } else {
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexTextureCoordinateBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexTextureCoordinateAttribute, vertexTextureCoordinateBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, cubeTexture);
      gl.uniform1i(gl.getUniformLocation(shaderProgram, "uSampler"), 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
      setMatrixUniforms();
      gl.uniform1i(shaderProgram.meshBoolUniform, false);
      gl.drawElements(gl.TRIANGLES, vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
      if (window.main.meshBool) {
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexLinePositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexLinePositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexLineIndexBuffer);
        setMatrixUniforms();
        gl.uniform1i(shaderProgram.meshBoolUniform, true);
        return gl.drawElements(gl.LINES, vertexLineIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
      }
    };

    drawScene = function(px, py, pz, pw) {
      var aa, ab, d, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, len8, len9, m, n, o, p, q, r, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, s, t, u, w, x, y, z;
      createCubeTexture(' ');
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      mat4.perspective(pMatrix, 45, gl.viewportWidth / gl.viewportHeight, 0.001, 100.0);
      mat4.identity(mvMatrix);
      vec4.set(pVector, px, py, pz, pw);
      vec4.set(lightDirectionVector, window.main.lightX, window.main.lightY, window.main.lightZ, window.main.lightW);
      vec4.normalize(lightDirectionVector, lightDirectionVector);
      d = 2.0 + window.main.separation;
      n = window.main.cellCount;
      for (x = j = ref = -n, ref1 = n; ref <= ref1 ? j <= ref1 : j >= ref1; x = ref <= ref1 ? ++j : --j) {
        ref2 = [-n, n];
        for (k = 0, len = ref2.length; k < len; k++) {
          y = ref2[k];
          ref3 = [-n, n];
          for (l = 0, len1 = ref3.length; l < len1; l++) {
            z = ref3[l];
            ref4 = [-n, n];
            for (m = 0, len2 = ref4.length; m < len2; m++) {
              w = ref4[m];
              drawTesseract(d * x, d * y, d * z, d * w);
            }
          }
        }
      }
      ref5 = [-n, n];
      for (o = 0, len3 = ref5.length; o < len3; o++) {
        x = ref5[o];
        for (y = p = ref6 = -n, ref7 = n; ref6 <= ref7 ? p <= ref7 : p >= ref7; y = ref6 <= ref7 ? ++p : --p) {
          ref8 = [-n, n];
          for (q = 0, len4 = ref8.length; q < len4; q++) {
            z = ref8[q];
            ref9 = [-n, n];
            for (r = 0, len5 = ref9.length; r < len5; r++) {
              w = ref9[r];
              drawTesseract(d * x, d * y, d * z, d * w);
            }
          }
        }
      }
      ref10 = [-n, n];
      for (s = 0, len6 = ref10.length; s < len6; s++) {
        x = ref10[s];
        ref11 = [-n, n];
        for (t = 0, len7 = ref11.length; t < len7; t++) {
          y = ref11[t];
          for (z = u = ref12 = -n, ref13 = n; ref12 <= ref13 ? u <= ref13 : u >= ref13; z = ref12 <= ref13 ? ++u : --u) {
            ref14 = [-n, n];
            for (aa = 0, len8 = ref14.length; aa < len8; aa++) {
              w = ref14[aa];
              drawTesseract(d * x, d * y, d * z, d * w);
            }
          }
        }
      }
      ref15 = [-n, n];
      results = [];
      for (ab = 0, len9 = ref15.length; ab < len9; ab++) {
        x = ref15[ab];
        results.push((function() {
          var ac, len10, ref16, results1;
          ref16 = [-n, n];
          results1 = [];
          for (ac = 0, len10 = ref16.length; ac < len10; ac++) {
            y = ref16[ac];
            results1.push((function() {
              var ad, len11, ref17, results2;
              ref17 = [-n, n];
              results2 = [];
              for (ad = 0, len11 = ref17.length; ad < len11; ad++) {
                z = ref17[ad];
                results2.push((function() {
                  var ae, ref18, ref19, results3;
                  results3 = [];
                  for (w = ae = ref18 = -n, ref19 = n; ref18 <= ref19 ? ae <= ref19 : ae >= ref19; w = ref18 <= ref19 ? ++ae : --ae) {
                    results3.push(drawTesseract(d * x, d * y, d * z, d * w));
                  }
                  return results3;
                })());
              }
              return results2;
            })());
          }
          return results1;
        })());
      }
      return results;
    };

    center = {
      x: 0.0,
      y: 0.0
    };

    mouseDragging = false;

    dragOffset = {
      x: 0,
      y: 0
    };

    dragStart = {
      x: 0,
      y: 0
    };

    dragCurrent = {
      x: 0,
      y: 0
    };

    currentDirection = {
      forward: 0,
      right: 0,
      up: 0,
      charm: 0
    };

    moveSpeed = 0.01;

    px = 0;

    py = 0;

    pz = 25;

    pw = -30;

    modalRotate = function(x0, y0) {
      var x, y;
      x = x0 * 2.0 * Math.PI;
      y = y0 * 2.0 * Math.PI;
      r1Float = window.main.rhXY * x + window.main.rvXY * y;
      r2Float = window.main.rhXZ * x + window.main.rvXZ * y;
      r3Float = window.main.rhXW * x + window.main.rvXW * y;
      r4Float = window.main.rhYZ * x + window.main.rvYZ * y;
      r5Float = window.main.rhYW * x + window.main.rvYW * y;
      return r6Float = window.main.rhZW * x + window.main.rvZW * y;
    };

    rSpeeds = (function() {
      var j, results;
      results = [];
      for (i = j = 1; j <= 6; i = ++j) {
        results.push(2.0 * randAngle());
      }
      return results;
    })();

    updateSpeeds = function() {
      var j, results;
      results = [];
      for (i = j = 0; j <= 5; i = ++j) {
        results.push(rSpeeds[i] += randAngle() / 100);
      }
      return results;
    };

    lastTime = 0;

    animate = function() {
      var elapsed, timeNow;
      timeNow = (new Date).getTime();
      if (lastTime !== 0) {
        elapsed = timeNow - lastTime;
        pz -= currentDirection.forward * moveSpeed * elapsed;
        px += currentDirection.right * moveSpeed * elapsed;
        py += currentDirection.up * moveSpeed * elapsed;
        pw += currentDirection.charm * moveSpeed * elapsed;
        if (window.main.autoRotate) {
          updateSpeeds();
          r1Float += rSpeeds[0] * elapsed * window.main.autoRotateSpeed / 50000;
          r2Float += rSpeeds[1] * elapsed * window.main.autoRotateSpeed / 50000;
          r3Float += rSpeeds[2] * elapsed * window.main.autoRotateSpeed / 50000;
          r4Float += rSpeeds[3] * elapsed * window.main.autoRotateSpeed / 50000;
          r5Float += rSpeeds[4] * elapsed * window.main.autoRotateSpeed / 50000;
          r6Float += rSpeeds[5] * elapsed * window.main.autoRotateSpeed / 50000;
        }
      }
      return lastTime = timeNow;
    };

    timeNow = 0;

    fps = 0;

    timeLast = 0;

    computeFPS = function() {
      timeNow = new Date().getTime();
      fps++;
      if (timeNow - timeLast >= 1000) {
        document.getElementById('fps').innerHTML = "FPS: " + (Number(fps * 1000.0 / (timeNow - timeLast)).toPrecision(5));
        timeLast = timeNow;
        return fps = 0;
      }
    };

    tick = function() {
      requestAnimFrame(tick);
      computeFPS();
      drawScene(px, py, pz, pw);
      return animate();
    };

    window.testing = function() {
      var canvas, finishGLInit, getMousePos, handleKeyPress, handleKeyRelease, waitForShaders;
      canvas = document.getElementById('canvas');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      getMousePos = (function(_this) {
        return function(event) {
          var rect;
          rect = canvas.getBoundingClientRect();
          return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
          };
        };
      })(this);
      canvas.addEventListener("mousedown", (function(_this) {
        return function(e) {
          dragStart = dragCurrent = getMousePos(e);
          return mouseDragging = true;
        };
      })(this));
      canvas.addEventListener("mousemove", (function(_this) {
        return function(e) {
          var turnRight, turnUp;
          if (mouseDragging) {
            dragCurrent = getMousePos(e);
            turnRight = (dragStart.x - dragCurrent.x) / canvas.width;
            turnUp = (dragStart.y - dragCurrent.y) / canvas.height;
            return modalRotate(turnRight, turnUp);
          }
        };
      })(this));
      canvas.addEventListener("mouseup", (function(_this) {
        return function(e) {
          mouseDragging = false;
          center.x = center.x + (dragStart.x - dragCurrent.x) / canvas.width;
          center.y = center.y + (dragStart.y - dragCurrent.y) / canvas.height;
          return dragStart = dragCurrent = {
            x: 0.0,
            y: 0.0
          };
        };
      })(this));
      handleKeyPress = function(event) {
        var code;
        code = event.keyCode;
        console.log(code);
        switch (code) {
          case 87:
            return currentDirection.forward = 1;
          case 65:
            return currentDirection.right = -1;
          case 68:
            return currentDirection.right = 1;
          case 83:
            return currentDirection.forward = -1;
          case 69:
            return currentDirection.up = 1;
          case 81:
            return currentDirection.up = -1;
          case 82:
            return currentDirection.charm = 1;
          case 70:
            return currentDirection.charm = -1;
        }
      };
      handleKeyRelease = function(event) {
        var code;
        code = event.keyCode;
        switch (code) {
          case 87:
            currentDirection.forward = 0;
            break;
          case 65:
            currentDirection.right = 0;
            break;
          case 68:
            currentDirection.right = 0;
            break;
          case 83:
            currentDirection.forward = 0;
            break;
          case 69:
            currentDirection.up = 0;
            break;
          case 81:
            currentDirection.up = 0;
            break;
          case 82:
            currentDirection.charm = 0;
            break;
          case 70:
            currentDirection.charm = 0;
        }
        return console.log("position: (" + px + ", " + py + ", " + pz + ", " + pw + ")");
      };
      window.addEventListener("keydown", handleKeyPress, false);
      window.addEventListener("keyup", handleKeyRelease, false);
      initGL(canvas);
      loadShader('shaders/fragment.glsl', 'frag');
      loadShader('shaders/vertex.glsl', 'vert');
      cubeTexture = createCubeTexture("Hello World!");
      waitForShaders = function(continuation) {
        if (!(shaders.fragReady && shaders.vertReady)) {
          return setTimeout((function() {
            return waitForShaders(continuation);
          }), 10);
        } else {
          return continuation();
        }
      };
      finishGLInit = function() {
        initShaders();
        initBuffers();
        gl.clearColor(0.0, 0.0, 0.0, 1);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.DEPTH_TEST);
        document.getElementById('previewImage').style.display = 'none';
        window.main.GL = gl;
        return tick();
      };
      return waitForShaders(finishGLInit);
    };

    window.addEventListener('resize', (function() {
      return window.location.reload();
    }));

    return Main;

  })();

  window.onload = function() {
    var folderLightDirection, folderRotationControl, glbController, gldtController, gui, horizontalRotations, meshColorController, verticalRotations;
    window.main = new Main();
    window.testing();
    gui = new dat.GUI();
    gui.add(main, 'cornerNormals');
    gui.add(main, 'meshBool');
    meshColorController = gui.addColor(main, 'meshColorGui');
    meshColorController.onChange(function(value) {
      var c;
      c = value;
      return window.main.meshColor = vec4.fromValues(c[0], c[1], c[2], c[3]);
    });
    gui.add(main, 'separation', 0, 2);
    gui.add(main, 'cellCount').min(0).max(8).step(1);
    gldtController = gui.add(main, 'GLDepthTest');
    gldtController.onChange(function(v) {
      var GL;
      GL = window.main.GL;
      if (v) {
        return GL.enable(GL.DEPTH_TEST);
      } else {
        return GL.disable(GL.DEPTH_TEST);
      }
    });
    glbController = gui.add(main, 'GLBlend');
    glbController.onChange(function(v) {
      var GL;
      GL = window.main.GL;
      if (v) {
        return GL.enable(GL.BLEND);
      } else {
        return GL.disable(GL.BLEND);
      }
    });
    folderLightDirection = gui.addFolder('light direction');
    folderLightDirection.add(main, 'lightX');
    folderLightDirection.add(main, 'lightY');
    folderLightDirection.add(main, 'lightZ');
    folderLightDirection.add(main, 'lightW');
    folderLightDirection.open();
    gui.add(main, 'autoRotate');
    gui.add(main, 'autoRotateSpeed');
    folderRotationControl = gui.addFolder('rotation control');
    horizontalRotations = folderRotationControl.addFolder('horizontal');
    horizontalRotations.add(main, 'rhXY');
    horizontalRotations.add(main, 'rhXZ');
    horizontalRotations.add(main, 'rhXW');
    horizontalRotations.add(main, 'rhYZ');
    horizontalRotations.add(main, 'rhYW');
    horizontalRotations.add(main, 'rhZW');
    verticalRotations = folderRotationControl.addFolder('vertical');
    verticalRotations.add(main, 'rvXY');
    verticalRotations.add(main, 'rvXZ');
    verticalRotations.add(main, 'rvXW');
    verticalRotations.add(main, 'rvYZ');
    verticalRotations.add(main, 'rvYW');
    verticalRotations.add(main, 'rvZW');
    folderRotationControl.open();
    horizontalRotations.open();
    return verticalRotations.open();
  };

}).call(this);

//# sourceMappingURL=main.js.map
